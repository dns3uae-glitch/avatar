<!DOCTYPE html>
<html lang="ar">
<head>
<meta charset="utf-8" />
<title>مسرح الجريمة - مع نموذج GLB</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  html,body{height:100%;margin:0;background:#202020;overflow:hidden}
  canvas{display:block}
  .controls{
    position:absolute; bottom:18px; left:50%; transform:translateX(-50%);
    display:grid; grid-template-areas: ". up ." "left . right" ". down ."; gap:8px;
    z-index:30;
  }
  .controls button{
    width:48px;height:48px;border-radius:8px;border:0;background:#333;color:#fff;font-size:18px;
    box-shadow:0 2px 6px rgba(0,0,0,0.6);
    touch-action: none;
  }
  #loading {
    position: absolute; top: 12px; left: 12px; color:#fff; font-family: sans-serif;
    background: rgba(0,0,0,0.5); padding:8px 10px; border-radius:6px; z-index:40;
  }
</style>
</head>
<body>
<div id="loading">جاري تحميل المشهد...</div>

<div class="controls" aria-hidden="true">
  <button id="up">↑</button>
  <button id="down">↓</button>
  <button id="left">←</button>
  <button id="right">→</button>
</div>

<!-- Three.js and loaders (non-module) -->
<script src="https://cdn.jsdelivr.net/npm/three@0.155.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.155.0/examples/js/loaders/GLTFLoader.js"></script>

<script>
/*
  صفحة تعرض مشهد مسرح جريمة وتحمّل نموذج GLB من الرابط الذي أعطيته.
  ميزات:
   - تحميل Musket_FBX.glb وعرضه داخل الغرفة
   - التوهّج عند المرور (hover)
   - سحب بالمؤشر / اللمس لتحريك العنصر
   - التحكم بالكاميرا عبر أزرار الأسهم الظاهرة أو مفتاح السهم على الكيبورد
*/

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x202020);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 100);
camera.position.set(0, 1.6, 4);

const renderer = new THREE.WebGLRenderer({antialias: true});
renderer.setSize(window.innerWidth, window.innerHeight);
// نطّلع الظلال معلقين (قد تُسبب مشاكل على بعض الأجهزة) - إذا أردت تفعيل الظلال ضع true
renderer.shadowMap.enabled = false;
document.body.appendChild(renderer.domElement);

window.addEventListener('resize', ()=>{
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

// إضاءة مناسبة لرؤية جيدة على كل الأجهزة
const ambient = new THREE.AmbientLight(0xffffff, 0.7);
scene.add(ambient);

const dir = new THREE.DirectionalLight(0xffffff, 0.6);
dir.position.set(5, 10, 5);
scene.add(dir);

// أرضية وجدران بسيطة متناسبة مع الكاميرا
const floorMat = new THREE.MeshStandardMaterial({ color: 0x5a3f2a, roughness: 1.0 });
const floor = new THREE.Mesh(new THREE.PlaneGeometry(8, 8), floorMat);
floor.rotation.x = -Math.PI/2;
floor.position.y = 0;
scene.add(floor);

const wallMat = new THREE.MeshStandardMaterial({ color: 0x8a8a8a, roughness: 1.0 });
const backWall = new THREE.Mesh(new THREE.PlaneGeometry(8, 4), wallMat);
backWall.position.set(0, 2, -4);
scene.add(backWall);

// طاولة لوضع الأدلة عليها
const table = new THREE.Mesh(new THREE.BoxGeometry(2, 0.08, 1), new THREE.MeshStandardMaterial({ color: 0x2a2a2a, roughness: 0.6 }));
table.position.set(0, 0.5, 0);
scene.add(table);

// مصفوفة للعناصر التفاعلية
const interactiveObjects = [];

// رابط النموذج الذي طلبته
const modelURL = 'https://dns3uae-glitch.github.io/avatar/presets/Musket_FBX.glb';

// GLTFLoader
const loader = new THREE.GLTFLoader();

loader.load(
  modelURL,
  (gltf) => {
    const model = gltf.scene || gltf.scenes[0];
    // ضبط المقاس والموقع ليظهر طبيعيًا فوق الطاولة
    model.scale.set(0.9, 0.9, 0.9); // جرب زيادات أو إنقاص حسب الحاجة
    model.position.set(0, 0.55, 0); // فوق الطاولة
    model.rotation.set(0, Math.PI, 0);

    // تحسين خفيف للمواد داخل النموذج
    model.traverse(node => {
      if (node.isMesh) {
        // تفعيل استقبال الظل لو رغبت لاحقًا
        node.castShadow = false;
        node.receiveShadow = false;
        // إذا المادة موجودة عدّل الخواص لتبدو أكثر واقعية
        if (node.material) {
          if ('metalness' in node.material) node.material.metalness = Math.max(node.material.metalness || 0, 0.6);
          if ('roughness' in node.material) node.material.roughness = Math.min(node.material.roughness || 0.6, 0.9);
          // تأكد أن emissive موجودة لتستخدمها عند التوهج
          node.material.emissive = node.material.emissive || new THREE.Color(0x000000);
        }
      }
    });

    scene.add(model);
    interactiveObjects.push(model);

    // إزالة رسالة التحميل
    const loadEl = document.getElementById('loading');
    if (loadEl) loadEl.style.display = 'none';
    console.log('Model loaded:', model);
  },
  (xhr) => {
    // تقدم التحميل
    const pct = xhr.total ? Math.round((xhr.loaded / xhr.total) * 100) : null;
    document.getElementById('loading').innerText = 'تحميل: ' + (pct ? pct + '%' : 'جاري...');
  },
  (err) => {
    console.error('خطأ تحميل النموذج:', err);
    document.getElementById('loading').innerText = 'خطأ في تحميل النموذج: تحقق من المسار أو CORS';
  }
);

// ===== التفاعل (نقر / سحب / hover) باستخدام Raycaster + pointer events =====
const raycaster = new THREE.Raycaster();
const pointer = new THREE.Vector2();
let selected = null;
let pointerDown = false;

function setPointer(e){
  const x = (e.clientX ?? e.touches?.[0]?.clientX) || 0;
  const y = (e.clientY ?? e.touches?.[0]?.clientY) || 0;
  pointer.x = (x / window.innerWidth) * 2 - 1;
  pointer.y = - (y / window.innerHeight) * 2 + 1;
}

// pointer events لتوافق أفضل مع اللمس والماوس
window.addEventListener('pointermove', (e)=>{
  setPointer(e);
});

window.addEventListener('pointerdown', (e)=>{
  pointerDown = true;
  setPointer(e);
  raycaster.setFromCamera(pointer, camera);
  const hits = raycaster.intersectObjects(interactiveObjects, true);
  if (hits.length){
    // خذ المجموعة الأعلى (الجذر)
    let obj = hits[0].object;
    while (obj.parent && !interactiveObjects.includes(obj)) obj = obj.parent;
    selected = obj;
    // تمييز الاختيار بتوهج خفيف
    selected.traverse(n => { if (n.isMesh && n.material) n.material.emissive.setHex(0x222222); });
  }
});

window.addEventListener('pointerup', (e)=>{
  pointerDown = false;
  if (selected){
    // ازالة التوهج
    selected.traverse(n => { if (n.isMesh && n.material) n.material.emissive.setHex(0x000000); });
  }
  selected = null;
});

// ===== كاميرا تحكم بواسطة أزرار الشاشة (كما طلبت سابقًا) =====
const moveSpeed = 0.09;
const rotateSpeed = 0.03;
let cameraRotationY = 0;
const keys = { up:false, down:false, left:false, right:false };

document.getElementById('up').addEventListener('pointerdown', ()=> keys.up = true);
document.getElementById('up').addEventListener('pointerup', ()=> keys.up = false);
document.getElementById('down').addEventListener('pointerdown', ()=> keys.down = true);
document.getElementById('down').addEventListener('pointerup', ()=> keys.down = false);
document.getElementById('left').addEventListener('pointerdown', ()=> keys.left = true);
document.getElementById('left').addEventListener('pointerup', ()=> keys.left = false);
document.getElementById('right').addEventListener('pointerdown', ()=> keys.right = true);
document.getElementById('right').addEventListener('pointerup', ()=> keys.right = false);

window.addEventListener('keydown', e=>{
  if (e.key === 'ArrowUp') keys.up = true;
  if (e.key === 'ArrowDown') keys.down = true;
  if (e.key === 'ArrowLeft') keys.left = true;
  if (e.key === 'ArrowRight') keys.right = true;
});
window.addEventListener('keyup', e=>{
  if (e.key === 'ArrowUp') keys.up = false;
  if (e.key === 'ArrowDown') keys.down = false;
  if (e.key === 'ArrowLeft') keys.left = false;
  if (e.key === 'ArrowRight') keys.right = false;
});

// حلقة الرسوم
function animate(){
  requestAnimationFrame(animate);

  // تحريك الكاميرا بناءً على المفاتيح
  if (keys.left) cameraRotationY += rotateSpeed;
  if (keys.right) cameraRotationY -= rotateSpeed;
  const dirX = Math.sin(cameraRotationY), dirZ = Math.cos(cameraRotationY);
  if (keys.up){ camera.position.x += dirX * moveSpeed; camera.position.z += dirZ * moveSpeed; }
  if (keys.down){ camera.position.x -= dirX * moveSpeed; camera.position.z -= dirZ * moveSpeed; }
  camera.lookAt(camera.position.x + dirX, camera.position.y, camera.position.z + dirZ);

  // إذا هنالك عنصر محدد بالسحب، انقله على مستوى الأرض عند ارتفاعه
  if (selected && pointerDown){
    raycaster.setFromCamera(pointer, camera);
    const plane = new THREE.Plane(new THREE.Vector3(0,1,0), -selected.position.y);
    const pos = new THREE.Vector3();
    raycaster.ray.intersectPlane(plane, pos);
    if (pos) {
      selected.position.x = pos.x;
      selected.position.z = pos.z;
    }
  }

  // توهج hover: نتحقق من أي عنصر تحته المؤشر ونضع توهجًا بسيطًا
  raycaster.setFromCamera(pointer, camera);
  const hoverHits = raycaster.intersectObjects(interactiveObjects, true);
  // أزل توهج من كل العناصر أولًا
  interactiveObjects.forEach(obj => {
    obj.traverse(n => { if (n.isMesh && n.material) n.material.emissive.setHex(0x000000); });
  });
  if (hoverHits.length){
    let hovered = hoverHits[0].object;
    while (hovered.parent && !interactiveObjects.includes(hovered)) hovered = hovered.parent;
    hovered.traverse(n => { if (n.isMesh && n.material) n.material.emissive.setHex(0x222222); });
  }

  renderer.render(scene, camera);
}
animate();

</script>
</body>
</html>
